# hass-sungrowmodbus-amberelectric
# Background
This is the code I created for using [home-assistant](https://www.home-assistant.io/) to manage a Sungrow SH10RT-V112 inverter and a Sungrow 19.2kWh battery I have installed in my home. The Sungrow inverter I use has important hardware/firmware features that includes modbusTCP control, export limiting, and controlled charging/discharging of the battery. This leverages existing [Sungrow-SHx-Inverter-Modbus-Home-Assistant](https://github.com/mkaiser/Sungrow-SHx-Inverter-Modbus-Home-Assistant) Integration and the use case is specific to AmberElectric in Australia. AmberElectric is an Australian electricity retailer that allows customers to in effect, sell electricity (feed-in) at the wholesale electricity market rate. So the code here also leverages [AmberElectic ](https://www.home-assistant.io/integrations/amberelectric)integration available in home-assistant. The motivation for this work was to develop an open source alternative to the AmberElectric-provided mobile application that their customers can use with "Amber for Batteries". The idea is to use the access that AmberElectric provides to participate in the NEM (National Electricity Market) whilst managing the inverter locally to as great an extent as possible. This is my first crack at writing some automation and code for home-assistant. Feedback and comments are welcome.<br>Lastly, thanks to [Ippon Australia](https://au.ippon.tech) for supporting this endeavour and sponsoring my presentation of this work at the [Programmable Conference 2025](https://programmable.tech)
# Requirements
In addition to Sungrow-Modbus and AmberElectric, this code requires other integrations be installed/enabled in home-assistant including [pyscript](https://github.com/custom-components/pyscript) and [SQL](https://www.home-assistant.io/integrations/sql). For the AmberElectric Integration, you will also need to be an AmberElectric customer so you can create an API key to configure the AmberElectric home-assistant integration that accesses the AmberElectric price API via the internet.
# Code
The overarching design principle I have used is to control the inverter from a home-assistant jinja2 template and to only use pyscript to return a value for the best time to sell power in the battery. So the pyscript code just registers as a response-only service that is called by the automation as the first step in an action sequence. The service then returns an object to the automation, and the automation implements logic based on the values returned.<br>There are a couple of features I have included which are worth noting
* floor price, this is a pre-determined price below which it is not considered worthwhile to sell battery power
* overnight battery reserve, as opposed to minimum battery reserve level for backup during a grid outage
* prioritise power export over battery charging at times when the feed-in price is high (usually mornings), and prioritise charging the battery when the feed in price is lower or negative (during the middle of the day)

## sell-time.py
The home-assistant core I am using (2024.11.3) includes some handy math modules (pandas and numpy) which means it did not require any additional dependencies installed on my instance in order to run. However I did do most of the development using the [HASS Pyscript kernel shim for Jupyter](https://github.com/craigbarratt/hass-pyscript-jupyter/blob/master/README.md). In that case I have exported the python code from the notebook using ````jupyter nbconvert --to python sell-time.ipynb````. There are a couple of ancilliary functions in addition to the service registration which were defined to make the code simpler to read.<br>The basic idea is, given a battery discharge power and battery level, to pick a discharge start time that will maximise the sell-value of the power stored in the battery.<br> The algorithim uses a definite integration call (trapz from numpy) where each x-axis value corresponds to an interval from the future Feed-In price published by the AmberElectric API and stored in the home-assistant state attribute. The algorithm also attempts to correct for partial coverage of a discharge interval by applying a weight to a partial interval price in proportion (of time) to the interval length. The algorithm also includes features such as a floor feed-in price, below which it is not deemed worthwhile to sell power. This is done in order to preserve value of the battery cycles for better returns in the future. Note that using definite integration rather than simply picking the the price maximum is more likely to ensure a more favourable return from selling power, because it considers multiple adjacent intervals together.<br>The code returns a json object with some fields of use to the automation, this includes the best sell start interval and discharge duration. It also includes, for some arbitrary point in the future, how many intervals into the future from now is the best sell start, and an estimate of how much more it would earn compared to selling in the current interval. These last two values can be used by the automation to stop a current discharge if a better sell-start time is found in the future. A sell-start field in the returned object with ``1970-01-01 00:00:00+11:00`` indicates that there is currently no sell-start time found that is suitable. This is either because there is insufficient charge in the battery or no discharge interval with an average above the floor price has been identified.<br>
#### Installation
Once the pyscript custom component has been added to home-assistant, sell-time.py is copied to the /config/pyscript/ directory
## inverter-controller.j2
As indicated above, the jinja2 template is used to control the inverter based on the feed in price. As it stands the automation loop runs every 10 seconds, as this is how often the modbus integration polls the inverter.<br>
The inverter controller will use feed in price, not only to control the discharge of the battery. When the feed-in price is negative, AmberElectric customers are charged for exporting power. A negative RRP (Regional Reserve Price) can occur during periods of excess renewable generation in the Australian NEM (National Electricity Market). So an important function of the automation is also to enable/disable export limiting when the AmberElectric feed in is negative. Incidentally export limiting is a very important feature to have in an inverter for any prospective AmberElectric customers.<br>
The first step in the control flow which is common to subsequent branches, is to call the find-sell-start service and record the returned object. Then there are five subsequent distinct flows.<br>Three of the five flows are activated based on whether 1) the current feed-in price is zero, 2) negative or 3) positive. The logic in these branches will optimise the charging of the battery from solar at times when the feed-in price is likely to be minimal, prioritise exporting power over charging of the battery when feed-in prices are positive, or enable export limiting when the feed in price is negative when there is excess power being exported due to the power draw from limited household load or battery charging.<br>
The other two branches are triggered based on whether the Sungrow inverter has "forced mode" (ie exporting power from the battery to the grid) disabled or enabled.<br>If forced mode is disabled, the logic will determine, based on the return value from the find-sell-start service whether now is an interval to start selling/exporting power from the battery.<br>If forced-mode is enabled, the decision on whether to disable it is either based on whether the overnight battery reserve level has been reached or alternatively, a sufficiently better sell start time has been identified at some interval in the future. Note that the overnight battery reserve level is a dynamic value which is re-evaluated each time the integration is run. So the actual battery level at cutoff will depend how long until the next sunrise. In my case I want to have about 15% battery remaining at sunrise if the forced discharge ends at 9pm, which means the forced discharge would stop when the battery level is around 30% leaving enough for overnight use, fridge etc, with 15% remaining at sunrise. If the forced discharge ends after sunrise (which can happen when the automation sells power in the morning) then minimum reserve will be 10%. This is important to avoid charging from the grid, which happens if the battery drops below the minimum reserve level (inverter setting).
#### Installation
Installation is just a matter of creating a new automation using the home-assistant UI (Settings->Automations & Scenes-> Create Automation). Then open the new automation in the YAML editor and paste the contents into the editor window. Care must be taken to preserve indentation when pasting yaml.<br>Note that it may be necessary to update the jinja2 yaml to reflect what the various sensors are actually named on a given instance, for example ````sensor.amber_feed_in_price```` may not be appropriate on a different instance.
## configuration.yaml
The logic branches made by the inverter-controller can result in the inverter switching modes when it is not optimal. For example, there can be brief periods where the inverter might export power due to internal state changes, but it is not ideal to have these internally-induced fluctuations trigger a control flow. To counteract this I have added some SQL queries on the home-assistant database. The SQL integration adds the output of the queries to the home-assistant state, and they are available to determine automation flow in templates. In particular, the aggregate (average and peak) inverter export power over a pre-determined period (3 minutes) is used to give some smoothing when deciding whether to activate export limiting.<br>In addition, the inverter load power over a 10 minute interval is also aggregated and used to determine battery power available for export.<br>
#### Installation
The SQL query definitions can be added using the UI config for the integration, but in this case I have opted to add them in the main home-assistant configuration.yaml. 